## MSA 를 운영하면서 

### 1. 1 depth APIs  발생하는 문제
- Api 어디에 추가함?
  - 어디다 추가해야할지 명확한 기준이 없음. one 에 제공할 팀 api 추가해야하는데, app-api-one or app-api-team?
  - 현재 그 때마다 works 에 눈치보며 문의하고 대충 감대로 만듦.
    - 어느정도는 이 감이 옳을 수도 있겠으나, 명확한 기준이 없어서 나중에는 `모든 Api 의 구API 화` 무섭
- Api 모듈 새로만들어야할것 같음?
  - 새로운 서비스 나오면 기존 api에 우겨넣을까, 새로운 api 컴포넌트 만들까?
  - 매번 비슷한 논의들. 이 고민하는 시간조차 아깝다.

### 2. 백엔드 MSA 구조로 가기로 했지만 우리는 MSA 라기엔 지금은 단순한 상태
- inbound gateway : Loadbalancer ribbon, spring-cloud-gateway
- outbound gateway : circuitbreaker hystrix(fallback 시나리오), spring-cloud-gateway
- 예를 들면 100여개의 API 컴포넌트가 있고, 그 100여개 api 들이 서로 통신하고 있는 팀도 있다.
- 사용자의 요청은 필요한 만큼 depth 접근 할 수 있음. (상품결제요청 - 상품상태파악 - 잔고파악 - 결제 트랜잭션 - 영수증리턴)
- 하나의 트랜잭션은 모두 트래킹이 되어야함. 
- 각 서비스는 health check 를 할 수 있어야하고, 중앙에서 통제하는 녀석이 죽어잇는 서비스 살아잇는 서비스 판단하게 해줘야함.
- 그런걸 하기 위해 Service Discovery(Eureka), Tracing 도입

--------------------------

### 3. 이렇게 msa 엔 depth 제한이 없으나, 우리 서비스에 맞는 depth 는 필요한 것 같다.
- 100 여개 api 들고 있는 서비스는 하나의 개발팀은 아닐 것.
- 많은 depth = 잘게 쪼갠 서비스 = 운영적, 개발적으로 일 나누기는 편하지만 = 문제 생겼을 때 모니터링, 협업 어려움(but 담당만 찾으면 빨리 대응을 할수 있다는 관점도 있음)
- 그럼 우리는 2 or 3?  개인적으론 2 depth 면 충분하다고 봄. 그리고 2부턴 2나 3이나 그게 그거.

### 4. 1 depth 상태와 2 depth 이상 상태 비교
#### * 1 depth
##### 장점
- 지금 구조에서 따로 수정할 필요없고, api 정리 및 합치기만 하면 된다.
- 트랜젝션 트레킹 필요도 없다. 그냥 하나의 요청은 하나의 was로 가서 박히기 떄문에, 지금도 원하면 얼마든지 쉽게 트래킹 가능.
- 디버깅 쉽다. http request 적기 떄문에 속도 걱정할 필요 없다.
- 조금 체계가 없는 것 같아도 팀원과 합의하면서 api 추가 위치조절만 하면 된다.
- 앞으로 2~3년간은 큰 복잡함 없이 유지보수 할 수 있을것 같다 (2~3년 뒤 또 전면 개편할지도 모르는 판에)
- 나중에라도 체계를 잡고 싶을 때, Api 옮기기들만 하면, 아무 문제 없이 그떄가서 수정할 수 있다. (바로 지금처럼)
- 새로운 이가 와서 적응 했을 때 어렵지 않다.

##### 단점
- 개발자로서 죄책감/귀찮은 드는 코드가 생길 수는 있음.
- 확장성이 여러 depth 로 구성한 api에 비해 느릴 것. 또 api 추가하면서 새로 로직 짜야할 테고 맨날 똑같은 논의.
- 모든 api 가 잡탕이 될 확률도 있음.

--------------------------

#### * 2 depth 이상
- layer : [gateway] - [응용 API] - [리소스 API] 로 구분하는 경우
- 구분은 했지만 서로 어디서나 호출할 수 있다.
- 리소스 단계 3가지로 귀결.
  - 종목 별 API
  - 외부 API
  - 코어 컨텐츠 API 
  - 관리툴 API
- 응용 API : 필요없어지면 삭제해도 됨. core가 아니므로.
  - 검색 전용 : 컨검에서 개편하면 같이 삭제하고 새로만들면 됨.
  - 메인 전용
  - 특정 팀 전용
  - 이벤트 등 잡탕 API 
##### 장점
- Api 종류를 RESTFUL 하게 구성할 수 있다. API 컴포넌트 추가 삭제가 명확하다고 본다 -> 논의가 적어진다.
- 확장성 있다. 
- 5 에서 샘플 몇개 그려보겠지만 구조/나누는 기준이 비교적 명확하다.
- depth 1의 단점에서 자유롭다.
- 응용 layer 가 약간 비즈니스 로직이 들어갈 수 있을 텐데, 큰 부담 없을 것 같다.
##### 단점
- 한번 구축하고나면 flat 한 구조로 돌아가기가 힘들다. (서로 호출하는것 까지 다 바꿔야하니..)
- 개발 할 떄, 한 프로젝트에서 개발하는게 아니고, 여러 군데 작업 할 수도 있다.
- 여러 컴포넌트 작업하다보면, 배포시 주의해야 할 부분이 늘어난다.
- 느려질 확률도 있다. http request 가 늘어나므로, 조심해야한다. exception 이 나면 단순하게 바로 발견될 수 있지만, 응답이 조금씩 느린 경우는 잘 준비하지 않으면 병목 찾기가 쉽지 않다.
- 추가로 공부할게 많아져서 다같이 눈높이 맞추는데 시간 투자가 많이 필요하다. 여긴 장애시 다 달려들어 봐야하기 떄문에 구축한 시스템 모두 알아야 한다. 
- 리스트 형태의 api 에서 효율적인 방법을 찾아야한다.

### 5. 2 depth 로 갔을 때, 변경 되어야할 기술 스텍
- gateway ribbon : 안 써도 될 것 같음. 삭제해야함. 각 클러스터는 클러스터끼리 격리.
- zipkin sleuth : 요청 하나하나 놓치지 않을 수 있게 모니터링 툴 마련.
- 요청별 표준화 : 타 API 호출하는 영역에 서킷브레이커 무조건 적용. 공통 RestTemplate 만들어서 사용. (retry 금지, timeout 설정 등등)

### 7. 검토해 볼만한 기술
- [istio + envoy](https://blog.naver.com/PostView.nhn?blogId=sharplee7&logNo=222157988958) : 인프라 관점의 msa, api-gw 같은거 띄울필요 없고, Virtual Service + istio 설정
